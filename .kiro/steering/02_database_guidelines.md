---
title: データベース設計ガイドライン
inclusion: always
---

# SQLiteデータベース設計ガイドライン

## 主キーとインデックスの設計方針

### 主キー設計

1. **基本方針**:
   - すべてのテーブルに `_rowid_` という自動増分の主キーを追加
   - 元データにユニークなフィールドがない場合でも一意性を確保

2. **主キーの種類**:
   - **単一主キー**: 一つのカラムで一意性を確保できる場合
   - **複合主キー**: 複数のカラムの組み合わせで一意性を確保する場合
   - **自動生成主キー**: `_rowid_` を使用した自動増分主キー（デフォルト）

3. **主キー選定の優先順位**:
   - 自然キー（業務上の一意識別子）がある場合はそれを優先
   - 自然キーがない場合は `_rowid_` を使用

### インデックス設計

1. **インデックス作成の基準**:
   - 検索条件としてよく使用されるカラム
   - 結合操作で使用されるカラム
   - ソート操作で使用されるカラム

2. **インデックスの種類**:
   - **単一カラムインデックス**: 一つのカラムに対するインデックス
   - **複合インデックス**: 複数のカラムに対する一つのインデックス

3. **インデックス作成時の注意点**:
   - インデックスは検索を高速化するが、挿入・更新は遅くなる
   - 必要最小限のインデックスを作成する
   - カーディナリティ（値の種類の多さ）が高いカラムに作成する

## テーブル命名規則

1. **テーブル名**:
   - 小文字のスネークケース（例: `customer_order`）
   - 元のファイル名に基づく命名を基本とする
   - 日本語や特殊文字は避ける

2. **カラム名**:
   - 元のデータのカラム名をそのまま使用
   - 必要に応じて特殊文字をエスケープ

## データ型の最適化

1. **数値型**:
   - 整数: `INTEGER`
   - 小数: `REAL`

2. **文字列型**:
   - 固定長: `TEXT`（SQLiteでは `CHAR` と `VARCHAR` は内部的に `TEXT` として扱われる）
   - 可変長: `TEXT`

3. **日付時刻型**:
   - ISO8601形式の文字列として `TEXT` で格納
   - または整数型のUNIXタイムスタンプとして `INTEGER` で格納

4. **バイナリデータ**:
   - `BLOB` 型を使用

## パフォーマンス最適化

1. **トランザクション**:
   - 大量のデータ操作時はトランザクションを使用
   - `BEGIN TRANSACTION` と `COMMIT` で囲む

2. **インデックス**:
   - 大量データ挿入前にインデックスを削除し、挿入後に再作成
   - 複合条件での検索が多い場合は複合インデックスを検討

3. **VACUUM**:
   - 定期的に `VACUUM` を実行してデータベースを最適化
   - 大量のデータ削除後に特に効果的

4. **PRAGMA設定**:
   - `PRAGMA journal_mode = WAL`: 書き込みパフォーマンス向上
   - `PRAGMA synchronous = NORMAL`: 安全性とパフォーマンスのバランス
   - `PRAGMA cache_size`: メモリ使用量の調整

## エラー処理とリカバリ

1. **エラー検出**:
   - SQL操作の結果を常に確認
   - 例外をキャッチしてログに記録

2. **データ整合性**:
   - 重要な操作前にバックアップを作成
   - トランザクションを使用して一貫性を確保

3. **リカバリ手順**:
   - エラー発生時は変更をロールバック
   - 必要に応じてバックアップから復元